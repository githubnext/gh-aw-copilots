# This file was automatically generated by gh-aw. DO NOT EDIT.
# To update this file, edit the corresponding .md file and run:
#   gh aw compile

name: "Test Codex Mcp"
"on":
  issues:
    types:
    - opened

permissions: {}

concurrency:
  group: "gh-aw-${{ github.workflow }}-${{ github.event.issue.number }}"

run-name: "Test Codex Mcp"

jobs:
  add_reaction:
    if: github.event_name == 'issues' || github.event_name == 'pull_request' || github.event_name == 'issue_comment' || github.event_name == 'pull_request_comment' || github.event_name == 'pull_request_review_comment'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    outputs:
      reaction_id: ${{ steps.react.outputs.reaction-id }}
    steps:
      - name: Add eyes reaction to the triggering item
        id: react
        uses: actions/github-script@v7
        env:
          GITHUB_AW_REACTION: eyes
        with:
          script: |
            async function main() {
              // Read inputs from environment variables
              const reaction = process.env.GITHUB_AW_REACTION || 'eyes';
              console.log('Reaction type:', reaction);
              // Validate reaction type
              const validReactions = ['+1', '-1', 'laugh', 'confused', 'heart', 'hooray', 'rocket', 'eyes'];
              if (!validReactions.includes(reaction)) {
                core.setFailed(`Invalid reaction type: ${reaction}. Valid reactions are: ${validReactions.join(', ')}`);
                return;
              }
              // Determine the API endpoint based on the event type
              let endpoint;
              const eventName = context.eventName;
              const owner = context.repo.owner;
              const repo = context.repo.repo;
              try {
                switch (eventName) {
                  case 'issues':
                    const issueNumber = context.payload?.issue?.number;
                    if (!issueNumber) {
                      core.setFailed('Issue number not found in event payload');
                      return;
                    }
                    endpoint = `/repos/${owner}/${repo}/issues/${issueNumber}/reactions`;
                    break;
                  case 'issue_comment':
                    const commentId = context.payload?.comment?.id;
                    if (!commentId) {
                      core.setFailed('Comment ID not found in event payload');
                      return;
                    }
                    endpoint = `/repos/${owner}/${repo}/issues/comments/${commentId}/reactions`;
                    break;
                  case 'pull_request':
                  case 'pull_request_target':
                    const prNumber = context.payload?.pull_request?.number;
                    if (!prNumber) {
                      core.setFailed('Pull request number not found in event payload');
                      return;
                    }
                    // PRs are "issues" for the reactions endpoint
                    endpoint = `/repos/${owner}/${repo}/issues/${prNumber}/reactions`;
                    break;
                  case 'pull_request_review_comment':
                    const reviewCommentId = context.payload?.comment?.id;
                    if (!reviewCommentId) {
                      core.setFailed('Review comment ID not found in event payload');
                      return;
                    }
                    endpoint = `/repos/${owner}/${repo}/pulls/comments/${reviewCommentId}/reactions`;
                    break;
                  default:
                    core.setFailed(`Unsupported event type: ${eventName}`);
                    return;
                }
                console.log('API endpoint:', endpoint);
                await addReaction(endpoint, reaction);
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                console.error('Failed to add reaction:', errorMessage);
                core.setFailed(`Failed to add reaction: ${errorMessage}`);
              }
            }
            /**
             * Add a reaction to a GitHub issue, PR, or comment
             * @param {string} endpoint - The GitHub API endpoint to add the reaction to
             * @param {string} reaction - The reaction type to add
             */
            async function addReaction(endpoint, reaction) {
              const response = await github.request('POST ' + endpoint, {
                content: reaction,
                headers: {
                  'Accept': 'application/vnd.github+json'
                }
              });
              const reactionId = response.data?.id;
              if (reactionId) {
                console.log(`Successfully added reaction: ${reaction} (id: ${reactionId})`);
                core.setOutput('reaction-id', reactionId.toString());
              } else {
                console.log(`Successfully added reaction: ${reaction}`);
                core.setOutput('reaction-id', '');
              }
            }
            await main();

  test-codex-mcp:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read
      pull-requests: read
      discussions: read
      deployments: read
      models: read
    outputs:
      output: ${{ steps.collect_output.outputs.output }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
      - name: Install Codex
        run: npm install -g @openai/codex
      - name: Setup agent output
        id: setup_agent_output
        uses: actions/github-script@v7
        with:
          script: |
            function main() {
              const fs = require('fs');
              const crypto = require('crypto');
              // Generate a random filename for the output file
              const randomId = crypto.randomBytes(8).toString('hex');
              const outputFile = `/tmp/aw_output_${randomId}.txt`;
              // Ensure the /tmp directory exists and create empty output file
              fs.mkdirSync('/tmp', { recursive: true });
              fs.writeFileSync(outputFile, '', { mode: 0o644 });
              // Verify the file was created and is writable
              if (!fs.existsSync(outputFile)) {
                throw new Error(`Failed to create output file: ${outputFile}`);
              }
              // Set the environment variable for subsequent steps
              core.exportVariable('GITHUB_AW_SAFE_OUTPUTS', outputFile);
              console.log('Created agentic output file:', outputFile);
              // Also set as step output for reference
              core.setOutput('output_file', outputFile);
            }
            main();
      - name: Setup MCPs
        run: |
          mkdir -p /tmp/mcp-config
          cat > /tmp/mcp-config/config.toml << EOF
          [history]
          persistence = "none"
          
          [mcp_servers.github]
          command = "docker"
          args = [
            "run",
            "-i",
            "--rm",
            "-e",
            "GITHUB_PERSONAL_ACCESS_TOKEN",
            "ghcr.io/github/github-mcp-server:sha-45e90ae"
          ]
          env = { "GITHUB_PERSONAL_ACCESS_TOKEN" = "${{ secrets.GITHUB_TOKEN }}" }
          
          [mcp_servers.time]
          command = "docker"
          args = [
            "run",
            "--rm",
            "-i",
            "-e",
            "LOCAL_TIMEZONE",
            "mcp/time",
          ]
          env = { "LOCAL_TIMEZONE" = "${LOCAL_TIMEZONE}" }
          EOF
      - name: Create prompt
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          mkdir -p /tmp/aw-prompts
          cat > /tmp/aw-prompts/prompt.txt << 'EOF'
          **First, get the current time using the get_current_time tool to timestamp your analysis.**
          
          If the title of the issue #${{ github.event.issue.number }} is "Hello from Codex" then add a comment on the issue "Reply from Codex" with the current time.
          
          ### AI Attribution
          
          Include this footer in your PR comment:
          
          ```markdown
          > AI-generated content by [${{ github.workflow }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) may contain mistakes.
          ```
          
          
          ---
          
          ## Adding a Comment to an Issue or Pull Request
          
          To add a comment to an issue or pull request on GitHub, do NOT attempt to use MCP tools and do NOT attempt to use `gh` or the GitHub API. Instead, write the issue comment you want to make to the file "${{ env.GITHUB_AW_SAFE_OUTPUTS }}", in markdown.
          
          EOF
      - name: Print prompt to step summary
        run: |
          echo "## Generated Prompt" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat /tmp/aw-prompts/prompt.txt >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
      - name: Generate agentic run info
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            const awInfo = {
              engine_id: "codex",
              engine_name: "Codex",
              model: "",
              version: "",
              workflow_name: "Test Codex Mcp",
              experimental: true,
              supports_tools_whitelist: true,
              supports_http_transport: false,
              run_id: context.runId,
              run_number: context.runNumber,
              run_attempt: process.env.GITHUB_RUN_ATTEMPT,
              repository: context.repo.owner + '/' + context.repo.repo,
              ref: context.ref,
              sha: context.sha,
              actor: context.actor,
              event_name: context.eventName,
              created_at: new Date().toISOString()
            };
            
            // Write to /tmp directory to avoid inclusion in PR
            const tmpPath = '/tmp/aw_info.json';
            fs.writeFileSync(tmpPath, JSON.stringify(awInfo, null, 2));
            console.log('Generated aw_info.json at:', tmpPath);
            console.log(JSON.stringify(awInfo, null, 2));
      - name: Upload agentic run info
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw_info.json
          path: /tmp/aw_info.json
          if-no-files-found: warn
      - name: Run Codex
        run: |
          INSTRUCTION=$(cat /tmp/aw-prompts/prompt.txt)
          export CODEX_HOME=/tmp/mcp-config
          
          # Create log directory outside git repo
          mkdir -p /tmp/aw-logs
          
          # Run codex with log capture
          codex exec \
            -c model=o4-mini \
            --full-auto "$INSTRUCTION" 2>&1 | tee /tmp/test-codex-mcp.log
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          GITHUB_STEP_SUMMARY: ${{ env.GITHUB_STEP_SUMMARY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      - name: Check if workflow-complete.txt exists, if so upload it
        id: check_file
        run: |
          if [ -f workflow-complete.txt ]; then
            echo "File exists"
            echo "upload=true" >> $GITHUB_OUTPUT
          else
            echo "File does not exist"
            echo "upload=false" >> $GITHUB_OUTPUT
          fi
      - name: Upload workflow-complete.txt
        if: steps.check_file.outputs.upload == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: workflow-complete
          path: workflow-complete.txt
      - name: Collect agent output
        id: collect_output
        uses: actions/github-script@v7
        with:
          script: |
            /**
             * Sanitizes content for safe output in GitHub Actions
             * @param {string} content - The content to sanitize
             * @returns {string} The sanitized content
             */
            function sanitizeContent(content) {
              if (!content || typeof content !== 'string') {
                return '';
              }
              // Read allowed domains from environment variable
              const allowedDomainsEnv = process.env.GITHUB_AW_ALLOWED_DOMAINS;
              const defaultAllowedDomains = [
                'github.com',
                'github.io',
                'githubusercontent.com',
                'githubassets.com',
                'github.dev',
                'codespaces.new'
              ];
              const allowedDomains = allowedDomainsEnv
                ? allowedDomainsEnv.split(',').map(d => d.trim()).filter(d => d)
                : defaultAllowedDomains;
              let sanitized = content;
              // Neutralize @mentions to prevent unintended notifications
              sanitized = neutralizeMentions(sanitized);
              // Remove control characters (except newlines and tabs)
              sanitized = sanitized.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
              // XML character escaping
              sanitized = sanitized
                .replace(/&/g, '&amp;')   // Must be first to avoid double-escaping
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
              // URI filtering - replace non-https protocols with "(redacted)"
              // Step 1: Temporarily mark HTTPS URLs to protect them
              sanitized = sanitizeUrlProtocols(sanitized);
              // Domain filtering for HTTPS URIs
              // Match https:// URIs and check if domain is in allowlist
              sanitized = sanitizeUrlDomains(sanitized);
              // Limit total length to prevent DoS (0.5MB max)
              const maxLength = 524288;
              if (sanitized.length > maxLength) {
                sanitized = sanitized.substring(0, maxLength) + '\n[Content truncated due to length]';
              }
              // Limit number of lines to prevent log flooding (65k max)
              const lines = sanitized.split('\n');
              const maxLines = 65000;
              if (lines.length > maxLines) {
                sanitized = lines.slice(0, maxLines).join('\n') + '\n[Content truncated due to line count]';
              }
              // Remove ANSI escape sequences
              sanitized = sanitized.replace(/\x1b\[[0-9;]*[mGKH]/g, '');
              // Neutralize common bot trigger phrases
              sanitized = neutralizeBotTriggers(sanitized);
              // Trim excessive whitespace
              return sanitized.trim();
              /**
               * Remove unknown domains
               * @param {string} s - The string to process
               * @returns {string} The string with unknown domains redacted
               */
              function sanitizeUrlDomains(s) {
                s = s.replace(/\bhttps:\/\/([^\/\s\])}'"<>&\x00-\x1f]+)/gi, (match, domain) => {
                  // Extract the hostname part (before first slash, colon, or other delimiter)
                  const hostname = domain.split(/[\/:\?#]/)[0].toLowerCase();
                  // Check if this domain or any parent domain is in the allowlist
                  const isAllowed = allowedDomains.some(allowedDomain => {
                    const normalizedAllowed = allowedDomain.toLowerCase();
                    return hostname === normalizedAllowed || hostname.endsWith('.' + normalizedAllowed);
                  });
                  return isAllowed ? match : '(redacted)';
                });
                return s;
              }
              /**
               * Remove unknown protocols except https
               * @param {string} s - The string to process
               * @returns {string} The string with non-https protocols redacted
               */
              function sanitizeUrlProtocols(s) {
                // Match both protocol:// and protocol: patterns
                // This covers URLs like https://example.com, javascript:alert(), mailto:user@domain.com, etc.
                return s.replace(/\b(\w+):(?:\/\/)?[^\s\])}'"<>&\x00-\x1f]+/gi, (match, protocol) => {
                  // Allow https (case insensitive), redact everything else
                  return protocol.toLowerCase() === 'https' ? match : '(redacted)';
                });
              }
              /**
               * Neutralizes @mentions by wrapping them in backticks
               * @param {string} s - The string to process
               * @returns {string} The string with neutralized mentions
               */
              function neutralizeMentions(s) {
                // Replace @name or @org/team outside code with `@name`
                return s.replace(/(^|[^\w`])@([A-Za-z0-9](?:[A-Za-z0-9-]{0,37}[A-Za-z0-9])?(?:\/[A-Za-z0-9._-]+)?)/g,
                  (_m, p1, p2) => `${p1}\`@${p2}\``);
              }
              /**
               * Neutralizes bot trigger phrases by wrapping them in backticks
               * @param {string} s - The string to process
               * @returns {string} The string with neutralized bot triggers
               */
              function neutralizeBotTriggers(s) {
                // Neutralize common bot trigger phrases like "fixes #123", "closes #asdfs", etc.
                return s.replace(/\b(fixes?|closes?|resolves?|fix|close|resolve)\s+#(\w+)/gi,
                  (match, action, ref) => `\`${action} #${ref}\``);
              }
            }
            async function main() {
              const fs = require("fs");
              const outputFile = process.env.GITHUB_AW_SAFE_OUTPUTS;
              if (!outputFile) {
                console.log('GITHUB_AW_SAFE_OUTPUTS not set, no output to collect');
                core.setOutput('output', '');
                return;
              }
              if (!fs.existsSync(outputFile)) {
                console.log('Output file does not exist:', outputFile);
                core.setOutput('output', '');
                return;
              }
              const outputContent = fs.readFileSync(outputFile, 'utf8');
              if (outputContent.trim() === '') {
                console.log('Output file is empty');
                core.setOutput('output', '');
              } else {
                const sanitizedContent = sanitizeContent(outputContent);
                console.log('Collected agentic output (sanitized):', sanitizedContent.substring(0, 200) + (sanitizedContent.length > 200 ? '...' : ''));
                core.setOutput('output', sanitizedContent);
              }
            }
            await main();
      - name: Print agent output to step summary
        env:
          GITHUB_AW_SAFE_OUTPUTS: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
        run: |
          echo "## Agent Output" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '``````markdown' >> $GITHUB_STEP_SUMMARY
          cat ${{ env.GITHUB_AW_SAFE_OUTPUTS }} >> $GITHUB_STEP_SUMMARY
          echo '``````' >> $GITHUB_STEP_SUMMARY
      - name: Upload agentic output file
        if: always() && steps.collect_output.outputs.output != ''
        uses: actions/upload-artifact@v4
        with:
          name: aw_output.txt
          path: ${{ env.GITHUB_AW_SAFE_OUTPUTS }}
          if-no-files-found: warn
      - name: Parse agent logs for step summary
        if: always()
        uses: actions/github-script@v7
        env:
          AGENT_LOG_FILE: /tmp/test-codex-mcp.log
        with:
          script: |
            function main() {
              const fs = require('fs');
              try {
                const logFile = process.env.AGENT_LOG_FILE;
                if (!logFile) {
                  console.log('No agent log file specified');
                  return;
                }
                if (!fs.existsSync(logFile)) {
                  console.log(`Log file not found: ${logFile}`);
                  return;
                }
                const content = fs.readFileSync(logFile, 'utf8');
                const parsedLog = parseCodexLog(content);
                if (parsedLog) {
                  core.summary.addRaw(parsedLog).write();
                  console.log('Codex log parsed successfully');
                } else {
                  console.log('Failed to parse Codex log');
                }
              } catch (error) {
                core.setFailed(error.message);
              }
            }
            function parseCodexLog(logContent) {
              try {
                const lines = logContent.split('\n');
                let markdown = '## ðŸ¤– Commands and Tools\n\n';
                const commandSummary = [];
                // First pass: collect commands for summary
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  // Detect tool usage and exec commands
                  if (line.includes('] tool ') && line.includes('(')) {
                    // Extract tool name
                    const toolMatch = line.match(/\] tool ([^(]+)\(/);
                    if (toolMatch) {
                      const toolName = toolMatch[1];
                      // Look ahead to find the result status
                      let statusIcon = 'â“'; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes('success in')) {
                          statusIcon = 'âœ…';
                          break;
                        } else if (nextLine.includes('failure in') || nextLine.includes('error in') || nextLine.includes('failed in')) {
                          statusIcon = 'âŒ';
                          break;
                        }
                      }
                      if (toolName.includes('.')) {
                        // Format as provider::method
                        const parts = toolName.split('.');
                        const provider = parts[0];
                        const method = parts.slice(1).join('_');
                        commandSummary.push(`* ${statusIcon} \`${provider}::${method}(...)\``);
                      } else {
                        commandSummary.push(`* ${statusIcon} \`${toolName}(...)\``);
                      }
                    }
                  } else if (line.includes('] exec ')) {
                    // Extract exec command
                    const execMatch = line.match(/exec (.+?) in/);
                    if (execMatch) {
                      const formattedCommand = formatBashCommand(execMatch[1]);
                      // Look ahead to find the result status
                      let statusIcon = 'â“'; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes('succeeded in')) {
                          statusIcon = 'âœ…';
                          break;
                        } else if (nextLine.includes('failed in') || nextLine.includes('error')) {
                          statusIcon = 'âŒ';
                          break;
                        }
                      }
                      commandSummary.push(`* ${statusIcon} \`${formattedCommand}\``);
                    }
                  }
                }
                // Add command summary
                if (commandSummary.length > 0) {
                  for (const cmd of commandSummary) {
                    markdown += `${cmd}\n`;
                  }
                } else {
                  markdown += 'No commands or tools used.\n';
                }
                // Add Information section
                markdown += '\n## ðŸ“Š Information\n\n';
                // Extract metadata from Codex logs
                let totalTokens = 0;
                const tokenMatches = logContent.match(/tokens used: (\d+)/g);
                if (tokenMatches) {
                  for (const match of tokenMatches) {
                    const tokens = parseInt(match.match(/(\d+)/)[1]);
                    totalTokens += tokens;
                  }
                }
                if (totalTokens > 0) {
                  markdown += `**Total Tokens Used:** ${totalTokens.toLocaleString()}\n\n`;
                }
                // Count tool calls and exec commands
                const toolCalls = (logContent.match(/\] tool /g) || []).length;
                const execCommands = (logContent.match(/\] exec /g) || []).length;
                if (toolCalls > 0) {
                  markdown += `**Tool Calls:** ${toolCalls}\n\n`;
                }
                if (execCommands > 0) {
                  markdown += `**Commands Executed:** ${execCommands}\n\n`;
                }
                markdown += '\n## ðŸ¤– Reasoning\n\n';
                // Second pass: process full conversation flow with interleaved reasoning, tools, and commands
                let inThinkingSection = false;
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  // Skip metadata lines
                  if (line.includes('OpenAI Codex') || line.startsWith('--------') || 
                      line.includes('workdir:') || line.includes('model:') || 
                      line.includes('provider:') || line.includes('approval:') || 
                      line.includes('sandbox:') || line.includes('reasoning effort:') || 
                      line.includes('reasoning summaries:') || line.includes('tokens used:')) {
                    continue;
                  }
                  // Process thinking sections
                  if (line.includes('] thinking')) {
                    inThinkingSection = true;
                    continue;
                  }
                  // Process tool calls
                  if (line.includes('] tool ') && line.includes('(')) {
                    inThinkingSection = false;
                    const toolMatch = line.match(/\] tool ([^(]+)\(/);
                    if (toolMatch) {
                      const toolName = toolMatch[1];
                      // Look ahead to find the result status
                      let statusIcon = 'â“'; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes('success in')) {
                          statusIcon = 'âœ…';
                          break;
                        } else if (nextLine.includes('failure in') || nextLine.includes('error in') || nextLine.includes('failed in')) {
                          statusIcon = 'âŒ';
                          break;
                        }
                      }
                      if (toolName.includes('.')) {
                        const parts = toolName.split('.');
                        const provider = parts[0];
                        const method = parts.slice(1).join('_');
                        markdown += `${statusIcon} ${provider}::${method}(...)\n\n`;
                      } else {
                        markdown += `${statusIcon} ${toolName}(...)\n\n`;
                      }
                    }
                    continue;
                  }
                  // Process exec commands
                  if (line.includes('] exec ')) {
                    inThinkingSection = false;
                    const execMatch = line.match(/exec (.+?) in/);
                    if (execMatch) {
                      const formattedCommand = formatBashCommand(execMatch[1]);
                      // Look ahead to find the result status
                      let statusIcon = 'â“'; // Unknown by default
                      for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                        const nextLine = lines[j];
                        if (nextLine.includes('succeeded in')) {
                          statusIcon = 'âœ…';
                          break;
                        } else if (nextLine.includes('failed in') || nextLine.includes('error')) {
                          statusIcon = 'âŒ';
                          break;
                        }
                      }
                      markdown += `${statusIcon} \`${formattedCommand}\`\n\n`;
                    }
                    continue;
                  }
                  // Process thinking content
                  if (inThinkingSection && line.trim().length > 20 && !line.startsWith('[2025-')) {
                    const trimmed = line.trim();
                    // Add thinking content directly
                    markdown += `${trimmed}\n\n`;
                  }
                }
                return markdown;
              } catch (error) {
                console.error('Error parsing Codex log:', error);
                return '## ðŸ¤– Commands and Tools\n\nError parsing log content.\n\n## ðŸ¤– Reasoning\n\nUnable to parse reasoning from log.\n\n';
              }
            }
            function formatBashCommand(command) {
              if (!command) return '';
              // Convert multi-line commands to single line by replacing newlines with spaces
              // and collapsing multiple spaces
              let formatted = command
                .replace(/\n/g, ' ')           // Replace newlines with spaces
                .replace(/\r/g, ' ')           // Replace carriage returns with spaces
                .replace(/\t/g, ' ')           // Replace tabs with spaces
                .replace(/\s+/g, ' ')          // Collapse multiple spaces into one
                .trim();                       // Remove leading/trailing whitespace
              // Escape backticks to prevent markdown issues
              formatted = formatted.replace(/`/g, '\\`');
              // Truncate if too long (keep reasonable length for summary)
              const maxLength = 80;
              if (formatted.length > maxLength) {
                formatted = formatted.substring(0, maxLength) + '...';
              }
              return formatted;
            }
            function truncateString(str, maxLength) {
              if (!str) return '';
              if (str.length <= maxLength) return str;
              return str.substring(0, maxLength) + '...';
            }
            // Export for testing
            if (typeof module !== 'undefined' && module.exports) {
              module.exports = { parseCodexLog, formatBashCommand, truncateString };
            }
            main();
      - name: Upload agent logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-codex-mcp.log
          path: /tmp/test-codex-mcp.log
          if-no-files-found: warn
      - name: Generate git patch
        if: always()
        run: |
          # Check current git status
          echo "Current git status:"
          git status
          # Get the initial commit SHA from the base branch of the pull request
          if [ "$GITHUB_EVENT_NAME" = "pull_request" ] || [ "$GITHUB_EVENT_NAME" = "pull_request_review_comment" ]; then
            INITIAL_SHA="$GITHUB_BASE_REF"
          else
            INITIAL_SHA="$GITHUB_SHA"
          fi
          echo "Base commit SHA: $INITIAL_SHA"
          # Configure git user for GitHub Actions
          git config --global user.email "action@github.com"
          git config --global user.name "GitHub Action"
          # Stage any unstaged files
          git add -A || true
          # Check if there are staged files to commit
          if ! git diff --cached --quiet; then
            echo "Staged files found, committing them..."
            git commit -m "[agent] staged files" || true
            echo "Staged files committed"
          else
            echo "No staged files to commit"
          fi
          # Check updated git status
          echo "Updated git status after committing staged files:"
          git status
          # Show compact diff information between initial commit and HEAD (committed changes only)
          echo '## Git diff' >> $GITHUB_STEP_SUMMARY
          echo '' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          git diff --name-only "$INITIAL_SHA"..HEAD >> $GITHUB_STEP_SUMMARY || true
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo '' >> $GITHUB_STEP_SUMMARY
          # Check if there are any committed changes since the initial commit
          if git diff --quiet "$INITIAL_SHA" HEAD; then
            echo "No committed changes detected since initial commit"
            echo "Skipping patch generation - no committed changes to create patch from"
          else
            echo "Committed changes detected, generating patch..."
            # Generate patch from initial commit to HEAD (committed changes only)
            git format-patch "$INITIAL_SHA"..HEAD --stdout > /tmp/aw.patch || echo "Failed to generate patch" > /tmp/aw.patch
            echo "Patch file created at /tmp/aw.patch"
            ls -la /tmp/aw.patch
            # Show the first 50 lines of the patch for review
            echo '## Git Patch' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
            echo '```diff' >> $GITHUB_STEP_SUMMARY
            head -50 /tmp/aw.patch >> $GITHUB_STEP_SUMMARY || echo "Could not display patch contents" >> $GITHUB_STEP_SUMMARY
            echo '...' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo '' >> $GITHUB_STEP_SUMMARY
          fi
      - name: Upload git patch
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: aw.patch
          path: /tmp/aw.patch
          if-no-files-found: ignore

  create_issue_comment:
    needs: test-codex-mcp
    if: github.event.issue.number || github.event.pull_request.number
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
    timeout-minutes: 10
    outputs:
      comment_id: ${{ steps.create_comment.outputs.comment_id }}
      comment_url: ${{ steps.create_comment.outputs.comment_url }}
    steps:
      - name: Add Issue Comment
        id: create_comment
        uses: actions/github-script@v7
        env:
          GITHUB_AW_AGENT_OUTPUT: ${{ needs.test-codex-mcp.outputs.output }}
        with:
          script: |
            async function main() {
              // Read the agent output content from environment variable
              const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT;
              if (!outputContent) {
                console.log('No GITHUB_AW_AGENT_OUTPUT environment variable found');
                return;
              }
              if (outputContent.trim() === '') {
                console.log('Agent output content is empty');
                return;
              }
              console.log('Agent output content length:', outputContent.length);
              // Check if we're in an issue or pull request context
              const isIssueContext = context.eventName === 'issues' || context.eventName === 'issue_comment';
              const isPRContext = context.eventName === 'pull_request' || context.eventName === 'pull_request_review' || context.eventName === 'pull_request_review_comment';
              if (!isIssueContext && !isPRContext) {
                console.log('Not running in issue or pull request context, skipping comment creation');
                return;
              }
              // Determine the issue/PR number and comment endpoint
              let issueNumber;
              let commentEndpoint;
              if (isIssueContext) {
                if (context.payload.issue) {
                  issueNumber = context.payload.issue.number;
                  commentEndpoint = 'issues';
                } else {
                  console.log('Issue context detected but no issue found in payload');
                  return;
                }
              } else if (isPRContext) {
                if (context.payload.pull_request) {
                  issueNumber = context.payload.pull_request.number;
                  commentEndpoint = 'issues'; // PR comments use the issues API endpoint
                } else {
                  console.log('Pull request context detected but no pull request found in payload');
                  return;
                }
              }
              if (!issueNumber) {
                console.log('Could not determine issue or pull request number');
                return;
              }
              let body = outputContent.trim();
              // Add AI disclaimer with run id, run htmlurl
              const runId = context.runId;
              const runUrl = context.payload.repository 
                ? `${context.payload.repository.html_url}/actions/runs/${runId}`
                : `https://github.com/actions/runs/${runId}`;  
              body += `\n\n> Generated by Agentic Workflow Run [${runId}](${runUrl})\n`;
              console.log(`Creating comment on ${commentEndpoint} #${issueNumber}`);
              console.log('Comment content length:', body.length);
              // Create the comment using GitHub API
              const { data: comment } = await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: body
              });
              console.log('Created comment #' + comment.id + ': ' + comment.html_url);
              // Set output for other jobs to use
              core.setOutput('comment_id', comment.id);
              core.setOutput('comment_url', comment.html_url);
              // write comment id, url to the github_step_summary
              await core.summary.addRaw(`
            ## GitHub Comment
            - Comment ID: ${comment.id}
            - Comment URL: ${comment.html_url}
            `).write();
            }
            await main();

