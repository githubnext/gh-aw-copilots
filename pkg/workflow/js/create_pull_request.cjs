/** @type {typeof import("fs")} */
const fs = require("fs");
/** @type {typeof import("crypto")} */
const crypto = require("crypto");
const { execSync } = require("child_process");

async function main() {
  // Environment validation - fail early if required variables are missing
  const workflowId = process.env.GITHUB_AW_WORKFLOW_ID;
  if (!workflowId) {
    throw new Error("GITHUB_AW_WORKFLOW_ID environment variable is required");
  }

  const baseBranch = process.env.GITHUB_AW_BASE_BRANCH;
  if (!baseBranch) {
    throw new Error("GITHUB_AW_BASE_BRANCH environment variable is required");
  }

  const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT || "";
  if (outputContent.trim() === "") {
    console.log("Agent output content is empty");
  }

  // Check if patch file exists and has valid content
  if (!fs.existsSync("/tmp/aw.patch")) {
    console.log("No patch file found - no changes to create pull request for");
    console.log("Exiting gracefully as no-op (no changes detected)");
    return;
  }

  const patchContent = fs.readFileSync("/tmp/aw.patch", "utf8");
  if (
    !patchContent ||
    !patchContent.trim() ||
    patchContent.includes("Failed to generate patch") ||
    patchContent.includes(
      "Skipping patch generation - no committed changes to create patch from"
    )
  ) {
    console.log(
      "Patch file is empty or indicates no changes - no pull request needed"
    );
    console.log("Exiting gracefully as no-op (no changes detected)");
    return;
  }

  console.log("Agent output content length:", outputContent.length);
  console.log("Patch content validation passed");

  // Parse the validated output JSON
  let validatedOutput;
  try {
    validatedOutput = JSON.parse(outputContent);
  } catch (error) {
    console.log(
      "Error parsing agent output JSON:",
      error instanceof Error ? error.message : String(error)
    );
    return;
  }

  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
    console.log("No valid items found in agent output");
    return;
  }

  // Find the create-pull-request item
  const pullRequestItem = validatedOutput.items.find(
    /** @param {any} item */ item => item.type === "create-pull-request"
  );
  if (!pullRequestItem) {
    console.log("No create-pull-request item found in agent output");
    return;
  }

  console.log("Found create-pull-request item:", {
    title: pullRequestItem.title,
    bodyLength: pullRequestItem.body.length,
  });

  // Extract title, body, and branch from the JSON item
  let title = pullRequestItem.title.trim();
  let bodyLines = pullRequestItem.body.split("\n");
  let branchName = pullRequestItem.branch
    ? pullRequestItem.branch.trim()
    : null;

  // If no title was found, use a default
  if (!title) {
    title = "Agent Output";
  }

  // Apply title prefix if provided via environment variable
  const titlePrefix = process.env.GITHUB_AW_PR_TITLE_PREFIX;
  if (titlePrefix && !title.startsWith(titlePrefix)) {
    title = titlePrefix + title;
  }

  // Add AI disclaimer with run id, run htmlurl
  const runId = context.runId;
  const runUrl = context.payload.repository
    ? `${context.payload.repository.html_url}/actions/runs/${runId}`
    : `https://github.com/actions/runs/${runId}`;
  bodyLines.push(
    ``,
    ``,
    `> Generated by Agentic Workflow Run [${runId}](${runUrl})`,
    ""
  );

  // Prepare the body content
  const body = bodyLines.join("\n").trim();

  // Parse labels from environment variable (comma-separated string)
  const labelsEnv = process.env.GITHUB_AW_PR_LABELS;
  const labels = labelsEnv
    ? labelsEnv
        .split(",")
        .map(/** @param {string} label */ label => label.trim())
        .filter(/** @param {string} label */ label => label)
    : [];

  // Parse draft setting from environment variable (defaults to true)
  const draftEnv = process.env.GITHUB_AW_PR_DRAFT;
  const draft = draftEnv ? draftEnv.toLowerCase() === "true" : true;

  console.log("Creating pull request with title:", title);
  console.log("Labels:", labels);
  console.log("Draft:", draft);
  console.log("Body length:", body.length);

  // Use branch name from JSONL if provided, otherwise generate unique branch name
  if (!branchName) {
    console.log(
      "No branch name provided in JSONL, generating unique branch name"
    );
    // Generate unique branch name using cryptographic random hex
    const randomHex = crypto.randomBytes(8).toString("hex");
    branchName = `${workflowId}/${randomHex}`;
  } else {
    console.log("Using branch name from JSONL:", branchName);
  }

  console.log("Generated branch name:", branchName);
  console.log("Base branch:", baseBranch);

  // Create a new branch using git CLI
  // Configure git (required for commits)
  execSync('git config --global user.email "action@github.com"', {
    stdio: "inherit",
  });
  execSync('git config --global user.name "GitHub Action"', {
    stdio: "inherit",
  });

  // Handle branch creation/checkout
  const branchFromJsonl = pullRequestItem.branch
    ? pullRequestItem.branch.trim()
    : null;
  if (branchFromJsonl) {
    console.log("Checking if branch from JSONL exists:", branchFromJsonl);

    console.log(
      "Branch does not exist locally, creating new branch:",
      branchFromJsonl
    );
    execSync(`git checkout -b ${branchFromJsonl}`, { stdio: "inherit" });
    console.log("Using existing/created branch:", branchFromJsonl);
  } else {
    // Create and checkout new branch with generated name
    execSync(`git checkout -b ${branchName}`, { stdio: "inherit" });
    console.log("Created and checked out new branch:", branchName);
  }

  // Apply the patch using git CLI
  console.log("Applying patch...");

  // Apply the patch using git apply
  execSync("git apply /tmp/aw.patch", { stdio: "inherit" });
  console.log("Patch applied successfully");

  // Commit and push the changes
  execSync("git add .", { stdio: "inherit" });
  execSync(`git commit -m "Add agent output: ${title}"`, { stdio: "inherit" });
  execSync(`git push origin ${branchName}`, { stdio: "inherit" });
  console.log("Changes committed and pushed");

  // Create the pull request
  const { data: pullRequest } = await github.rest.pulls.create({
    owner: context.repo.owner,
    repo: context.repo.repo,
    title: title,
    body: body,
    head: branchName,
    base: baseBranch,
    draft: draft,
  });

  console.log(
    "Created pull request #" + pullRequest.number + ": " + pullRequest.html_url
  );

  // Add labels if specified
  if (labels.length > 0) {
    await github.rest.issues.addLabels({
      owner: context.repo.owner,
      repo: context.repo.repo,
      issue_number: pullRequest.number,
      labels: labels,
    });
    console.log("Added labels to pull request:", labels);
  }

  // Set output for other jobs to use
  core.setOutput("pull_request_number", pullRequest.number);
  core.setOutput("pull_request_url", pullRequest.html_url);
  core.setOutput("branch_name", branchName);

  // Write summary to GitHub Actions summary
  await core.summary
    .addRaw(
      `

## Pull Request
- **Pull Request**: [#${pullRequest.number}](${pullRequest.html_url})
- **Branch**: \`${branchName}\`
- **Base Branch**: \`${baseBranch}\`
`
    )
    .write();
}
await main();
