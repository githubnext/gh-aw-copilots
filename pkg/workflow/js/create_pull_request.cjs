/** @type {typeof import("fs")} */
const fs = require("fs");
/** @type {typeof import("crypto")} */
const crypto = require("crypto");
const { execSync } = require("child_process");

async function main() {
  // Environment validation - fail early if required variables are missing
  const workflowId = process.env.GITHUB_AW_WORKFLOW_ID;
  if (!workflowId) {
    throw new Error("GITHUB_AW_WORKFLOW_ID environment variable is required");
  }

  const baseBranch = process.env.GITHUB_AW_BASE_BRANCH;
  if (!baseBranch) {
    throw new Error("GITHUB_AW_BASE_BRANCH environment variable is required");
  }

  const outputContent = process.env.GITHUB_AW_AGENT_OUTPUT || "";
  if (outputContent.trim() === "") {
    console.log("Agent output content is empty");
  }

  const ifNoChanges = process.env.GITHUB_AW_PR_IF_NO_CHANGES || "warn";

  // Check if patch file exists and has valid content
  if (!fs.existsSync("/tmp/aw.patch")) {
    const message =
      "No patch file found - cannot create pull request without changes";

    switch (ifNoChanges) {
      case "error":
        throw new Error(message);
      case "ignore":
        // Silent success - no console output
        return;
      case "warn":
      default:
        console.log(message);
        return;
    }
  }

  const patchContent = fs.readFileSync("/tmp/aw.patch", "utf8");

  // Check for actual error conditions (but allow empty patches as valid noop)
  if (patchContent.includes("Failed to generate patch")) {
    const message =
      "Patch file contains error message - cannot create pull request without changes";

    switch (ifNoChanges) {
      case "error":
        throw new Error(message);
      case "ignore":
        // Silent success - no console output
        return;
      case "warn":
      default:
        console.log(message);
        return;
    }
  }

  // Empty patch is valid - behavior depends on if-no-changes configuration
  const isEmpty = !patchContent || !patchContent.trim();
  if (isEmpty) {
    const message =
      "Patch file is empty - no changes to apply (noop operation)";

    switch (ifNoChanges) {
      case "error":
        throw new Error(
          "No changes to push - failing as configured by if-no-changes: error"
        );
      case "ignore":
        // Silent success - no console output
        return;
      case "warn":
      default:
        console.log(message);
        return;
    }
  }

  console.log("Agent output content length:", outputContent.length);
  if (!isEmpty) {
    console.log("Patch content validation passed");
  } else {
    console.log("Patch file is empty - processing noop operation");
  }

  // Parse the validated output JSON
  let validatedOutput;
  try {
    validatedOutput = JSON.parse(outputContent);
  } catch (error) {
    console.log(
      "Error parsing agent output JSON:",
      error instanceof Error ? error.message : String(error)
    );
    return;
  }

  if (!validatedOutput.items || !Array.isArray(validatedOutput.items)) {
    console.log("No valid items found in agent output");
    return;
  }

  // Find all create-pull-request items (using filter instead of find)
  const pullRequestItems = validatedOutput.items.filter(
    /** @param {any} item */ item => item.type === "create-pull-request"
  );
  if (pullRequestItems.length === 0) {
    console.log("No create-pull-request item found in agent output");
    return;
  }

  // Process all items and create pull requests for each
  for (let i = 0; i < pullRequestItems.length; i++) {
    const pullRequestItem = pullRequestItems[i];

    console.log(
      `Processing pull request item ${i + 1}/${pullRequestItems.length}:`,
      {
        title: pullRequestItem.title,
        bodyLength: pullRequestItem.body.length,
      }
    );

    // Extract title, body, and branch from the JSON item
    let title = pullRequestItem.title.trim();
    let bodyLines = pullRequestItem.body.split("\n");
    let branchName = pullRequestItem.branch
      ? pullRequestItem.branch.trim()
      : null;

    // If no title was found, use a default
    if (!title) {
      title = "Agent Output";
    }

    // Apply title prefix if provided via environment variable
    const titlePrefix = process.env.GITHUB_AW_PR_TITLE_PREFIX;
    if (titlePrefix && !title.startsWith(titlePrefix)) {
      title = titlePrefix + title;
    }

    // Add AI disclaimer with run id, run htmlurl
    const runId = context.runId;
    const runUrl = context.payload.repository
      ? `${context.payload.repository.html_url}/actions/runs/${runId}`
      : `https://github.com/actions/runs/${runId}`;
    bodyLines.push(
      ``,
      ``,
      `> Generated by Agentic Workflow Run [${runId}](${runUrl})`,
      ""
    );

    // Prepare the body content
    const body = bodyLines.join("\n").trim();

    // Parse labels from environment variable (comma-separated string)
    const labelsEnv = process.env.GITHUB_AW_PR_LABELS;
    const labels = labelsEnv
      ? labelsEnv
          .split(",")
          .map(/** @param {string} label */ label => label.trim())
          .filter(/** @param {string} label */ label => label)
      : [];

    // Parse draft setting from environment variable (defaults to true)
    const draftEnv = process.env.GITHUB_AW_PR_DRAFT;
    const draft = draftEnv ? draftEnv.toLowerCase() === "true" : true;

    console.log("Creating pull request with title:", title);
    console.log("Labels:", labels);
    console.log("Draft:", draft);
    console.log("Body length:", body.length);

    // Use branch name from JSONL if provided, otherwise generate unique branch name
    if (!branchName) {
      console.log(
        "No branch name provided in JSONL, generating unique branch name"
      );
      // Generate unique branch name using cryptographic random hex
      const randomHex = crypto.randomBytes(8).toString("hex");
      branchName = `${workflowId}/${randomHex}`;
    } else {
      console.log("Using branch name from JSONL:", branchName);
    }

    console.log("Generated branch name:", branchName);
    console.log("Base branch:", baseBranch);

    // Handle branch creation/checkout (only do git config once)
    if (i === 0) {
      // Configure git (required for commits) - only do this once
      execSync('git config --global user.email "action@github.com"', {
        stdio: "inherit",
      });
      execSync('git config --global user.name "GitHub Action"', {
        stdio: "inherit",
      });
    }

    const branchFromJsonl = pullRequestItem.branch
      ? pullRequestItem.branch.trim()
      : null;
    if (branchFromJsonl) {
      console.log("Checking if branch from JSONL exists:", branchFromJsonl);

      console.log(
        "Branch does not exist locally, creating new branch:",
        branchFromJsonl
      );
      execSync(`git checkout -b ${branchFromJsonl}`, { stdio: "inherit" });
      console.log("Using existing/created branch:", branchFromJsonl);
    } else {
      // Create and checkout new branch with generated name
      execSync(`git checkout -b ${branchName}`, { stdio: "inherit" });
      console.log("Created and checked out new branch:", branchName);
    }

    // Apply the patch using git CLI (skip if empty)
    if (!isEmpty) {
      console.log("Applying patch...");
      execSync("git apply /tmp/aw.patch", { stdio: "inherit" });
      console.log("Patch applied successfully");
    } else {
      console.log("Skipping patch application (empty patch)");
    }

    // Commit and push the changes
    execSync("git add .", { stdio: "inherit" });

    // Check if there are changes to commit
    let hasChanges = false;
    let gitError = null;

    try {
      execSync("git diff --cached --exit-code", { stdio: "ignore" });
      // No changes - exit code 0
      hasChanges = false;
    } catch (error) {
      // Exit code != 0 means there are changes to commit, which is what we want
      hasChanges = true;
    }

    if (!hasChanges) {
      // No changes to commit - apply if-no-changes configuration
      const message =
        "No changes to commit - noop operation completed successfully";

      switch (ifNoChanges) {
        case "error":
          throw new Error(
            "No changes to commit - failing as configured by if-no-changes: error"
          );
        case "ignore":
          // Silent success - no console output
          continue; // Skip to next PR
        case "warn":
        default:
          console.log(message);
          continue; // Skip to next PR
      }
    }

    if (hasChanges) {
      execSync(`git commit -m "Add agent output: ${title}"`, {
        stdio: "inherit",
      });
      execSync(`git push origin ${branchName}`, { stdio: "inherit" });
      console.log("Changes committed and pushed");
    } else {
      // This should not happen due to the early return above, but keeping for safety
      console.log("No changes to commit");
      continue; // Skip to next PR
    }

    // Create the pull request
    const { data: pullRequest } = await github.rest.pulls.create({
      owner: context.repo.owner,
      repo: context.repo.repo,
      title: title,
      body: body,
      head: branchName,
      base: baseBranch,
      draft: draft,
    });

    console.log(
      "Created pull request #" +
        pullRequest.number +
        ": " +
        pullRequest.html_url
    );

    // Add labels if specified
    if (labels.length > 0) {
      await github.rest.issues.addLabels({
        owner: context.repo.owner,
        repo: context.repo.repo,
        issue_number: pullRequest.number,
        labels: labels,
      });
      console.log("Added labels to pull request:", labels);
    }

    // Set output for other jobs to use (for last PR, or overwrite each time)
    core.setOutput("pull_request_number", pullRequest.number);
    core.setOutput("pull_request_url", pullRequest.html_url);
    core.setOutput("branch_name", branchName);

    // Write summary to GitHub Actions summary
    await core.summary
      .addRaw(
        `

## Pull Request ${i + 1}
- **Pull Request**: [#${pullRequest.number}](${pullRequest.html_url})
- **Branch**: \`${branchName}\`
- **Base Branch**: \`${baseBranch}\`
`
      )
      .write();

    // If there are more items, switch back to base branch for the next iteration
    if (i < pullRequestItems.length - 1) {
      console.log("Switching back to base branch for next pull request");
      execSync(`git checkout ${baseBranch}`, { stdio: "inherit" });
    }
  }
}
await main();
