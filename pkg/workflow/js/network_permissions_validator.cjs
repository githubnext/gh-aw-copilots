/**
 * Network permissions validator for Claude Code engine.
 * Generated by gh-aw from engine network permissions configuration.
 */

/**
 * Extract domain from URL or search query
 * @param {string} urlOrQuery - The URL or search query to extract domain from
 * @returns {string|null} - The extracted domain or null if none found
 */
function extractDomain(urlOrQuery) {
  if (!urlOrQuery) {
    return null;
  }

  // Check for HTTP/HTTPS URLs
  if (urlOrQuery.startsWith('http://') || urlOrQuery.startsWith('https://')) {
    try {
      const url = new URL(urlOrQuery);
      return url.hostname.toLowerCase();
    } catch (error) {
      return null;
    }
  }

  // Check for domain patterns in search queries (site:domain.com)
  const siteMatch = urlOrQuery.match(/site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/);
  if (siteMatch) {
    return siteMatch[1].toLowerCase();
  }

  return null;
}

/**
 * Check if domain is allowed based on the allowed domains list
 * @param {string|null} domain - The domain to check
 * @param {string[]} allowedDomains - Array of allowed domain patterns
 * @param {string} toolName - The tool name (WebFetch or WebSearch) for context
 * @returns {boolean} - True if domain is allowed, false otherwise
 */
function isDomainAllowed(domain, allowedDomains, toolName = '') {
  if (!domain) {
    // For WebFetch, missing domain should always be blocked (malformed request)
    if (toolName === 'WebFetch') {
      return false;
    }
    // For WebSearch, if no domain detected, allow only if not under deny-all policy
    return allowedDomains.length > 0; // False if empty list (deny-all), true if has domains
  }

  // Empty allowed domains means deny all
  if (allowedDomains.length === 0) {
    return false;
  }

  // Check each pattern in allowed domains
  for (const pattern of allowedDomains) {
    // Convert wildcard pattern to regex
    const regexPattern = pattern
      .replace(/\./g, '\\.')  // Escape dots
      .replace(/\*/g, '.*');  // Convert * to .*
    
    const regex = new RegExp(`^${regexPattern}$`);
    if (regex.test(domain)) {
      return true;
    }
  }

  return false;
}

/**
 * Main validation function
 * @param {object} data - Input data containing tool_name and tool_input
 * @param {string[]} allowedDomains - Array of allowed domain patterns
 * @returns {object} - Validation result with allowed flag and messages
 */
function validateNetworkAccess(data, allowedDomains) {
  // Handle malformed/null data gracefully
  if (!data || typeof data !== 'object') {
    return {
      allowed: false,
      messages: ['Invalid input data provided']
    };
  }

  const toolName = data.tool_name || '';
  const toolInput = data.tool_input || {};

  // Allow other tools that aren't WebFetch or WebSearch
  if (!['WebFetch', 'WebSearch'].includes(toolName)) {
    return { allowed: true, messages: [] };
  }

  const target = toolInput.url || toolInput.query || '';
  const domain = extractDomain(target);

  // For WebSearch, apply domain restrictions consistently
  // If no domain detected in search query, check if restrictions are in place
  if (toolName === 'WebSearch' && !domain) {
    // Since this hook is only generated when network permissions are configured,
    // empty allowedDomains means deny-all policy
    if (allowedDomains.length === 0) {
      return {
        allowed: false,
        messages: [
          'Network access blocked: deny-all policy in effect',
          'No domains are allowed for WebSearch'
        ]
      };
    } else {
      return {
        allowed: false,
        messages: [
          'Network access blocked for WebSearch: no specific domain detected',
          `Allowed domains: ${allowedDomains.join(', ')}`
        ]
      };
    }
  }

  // Check if domain is allowed (this applies to both WebFetch and WebSearch)
  if (!isDomainAllowed(domain, allowedDomains, toolName)) {
    return {
      allowed: false,
      messages: [
        `Network access blocked for domain: ${domain}`,
        `Allowed domains: ${allowedDomains.join(', ')}`
      ]
    };
  }

  return { allowed: true, messages: [] };
}

// For testing purposes, export functions when in test environment
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    extractDomain,
    isDomainAllowed,
    validateNetworkAccess
  };
}

// Main execution when run as standalone script
async function main() {
  try {
    // Domain whitelist (populated during generation) - PLACEHOLDER_DOMAINS will be replaced
    const ALLOWED_DOMAINS = PLACEHOLDER_DOMAINS;

    // Read input data from stdin
    let inputData = '';
    for await (const chunk of process.stdin) {
      inputData += chunk;
    }

    if (!inputData.trim()) {
      console.error('No input data received');
      process.exit(2);
    }

    const data = JSON.parse(inputData);
    const result = validateNetworkAccess(data, ALLOWED_DOMAINS);

    if (!result.allowed) {
      // Output error messages to stderr
      for (const message of result.messages) {
        console.error(message);
      }
      process.exit(2); // Block with feedback to Claude
    }

    process.exit(0); // Allow
  } catch (error) {
    console.error(`Network validation error: ${error.message}`);
    process.exit(2); // Block on errors
  }
}

// Only run main if this is the main module (not being imported for testing)
if (require.main === module) {
  main();
}