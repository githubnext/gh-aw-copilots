import { describe, it, expect, beforeEach, vi } from 'vitest';
import fs from 'fs';
import path from 'path';

// Mock the global objects that GitHub Actions provides
const mockCore = {
  setOutput: vi.fn(),
  summary: {
    addRaw: vi.fn().mockReturnThis(),
    write: vi.fn()
  }
};

const mockGithub = {
  rest: {
    issues: {
      create: vi.fn(),
      createComment: vi.fn()
    }
  }
};

const mockContext = {
  runId: 12345,
  repo: {
    owner: 'testowner',
    repo: 'testrepo'
  },
  payload: {
    repository: {
      html_url: 'https://github.com/testowner/testrepo'
    }
  }
};

// Set up global variables
global.core = mockCore;
global.github = mockGithub;
global.context = mockContext;

describe('create_issue.cjs', () => {
  let createIssueScript;

  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks();
    
    // Reset environment variables
    delete process.env.GITHUB_AW_AGENT_OUTPUT;
    delete process.env.GITHUB_AW_ISSUE_LABELS;
    delete process.env.GITHUB_AW_ISSUE_TITLE_PREFIX;
    
    // Reset context
    delete global.context.payload.issue;
    
    // Read the script content
    const scriptPath = path.join(process.cwd(), 'pkg/workflow/js/create_issue.cjs');
    createIssueScript = fs.readFileSync(scriptPath, 'utf8');
  });

  it('should skip when no agent output is provided', async () => {
    delete process.env.GITHUB_AW_AGENT_OUTPUT;
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    expect(consoleSpy).toHaveBeenCalledWith('No GITHUB_AW_AGENT_OUTPUT environment variable found');
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();
    
    consoleSpy.mockRestore();
  });

  it('should skip when agent output is empty', async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = '   ';
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    expect(consoleSpy).toHaveBeenCalledWith('Agent output content is empty');
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();
    
    consoleSpy.mockRestore();
  });

  it('should create issue with default title when only body content provided', async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [{
        type: 'create-issue',
        body: 'This is the issue body content'
      }]
    });
    
    const mockIssue = {
      number: 456,
      html_url: 'https://github.com/testowner/testrepo/issues/456'
    };
    
    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    expect(mockGithub.rest.issues.create).toHaveBeenCalledWith({
      owner: 'testowner',
      repo: 'testrepo',
      title: 'This is the issue body content',
      body: expect.stringContaining('Generated by Agentic Workflow Run'),
      labels: []
    });
    
    expect(mockCore.setOutput).toHaveBeenCalledWith('issue_number', 456);
    expect(mockCore.setOutput).toHaveBeenCalledWith('issue_url', mockIssue.html_url);
    
    consoleSpy.mockRestore();
  });

  it('should extract title from markdown heading', async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [{
        type: 'create-issue',
        title: 'Bug Report',
        body: 'This is a detailed bug description\n\nSteps to reproduce:\n1. Step one'
      }]
    });
    
    const mockIssue = {
      number: 789,
      html_url: 'https://github.com/testowner/testrepo/issues/789'
    };
    
    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe('Bug Report');
    expect(callArgs.body).toContain('This is a detailed bug description');
    expect(callArgs.body).toContain('Steps to reproduce:');
    
    consoleSpy.mockRestore();
  });

  it('should handle labels from environment variable', async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [{
        type: 'create-issue',
        title: 'Issue with labels',
        body: 'Issue with labels'
      }]
    });
    process.env.GITHUB_AW_ISSUE_LABELS = 'bug, enhancement, high-priority';
    
    const mockIssue = {
      number: 101,
      html_url: 'https://github.com/testowner/testrepo/issues/101'
    };
    
    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual(['bug', 'enhancement', 'high-priority']);
    
    consoleSpy.mockRestore();
  });

  it('should apply title prefix when provided', async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [{
        type: 'create-issue', 
        title: 'Simple issue title',
        body: 'Simple issue title'
      }]
    });
    process.env.GITHUB_AW_ISSUE_TITLE_PREFIX = '[AUTO] ';
    
    const mockIssue = {
      number: 202,
      html_url: 'https://github.com/testowner/testrepo/issues/202'
    };
    
    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe('[AUTO] Simple issue title');
    
    consoleSpy.mockRestore();
  });

  it('should handle parent issue context and create comment', async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [{
        type: 'create-issue',
        title: 'Child issue content',
        body: 'Child issue content'
      }]
    });
    global.context.payload.issue = { number: 555 };
    
    const mockIssue = {
      number: 666,
      html_url: 'https://github.com/testowner/testrepo/issues/666'
    };
    
    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
    mockGithub.rest.issues.createComment.mockResolvedValue({});
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    // Should create the child issue with reference to parent
    const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(createArgs.body).toContain('Related to #555');
    
    // Should create comment on parent issue
    expect(mockGithub.rest.issues.createComment).toHaveBeenCalledWith({
      owner: 'testowner',
      repo: 'testrepo',
      issue_number: 555,
      body: 'Created related issue: #666'
    });
    
    consoleSpy.mockRestore();
  });

  it('should handle empty labels gracefully', async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [{
        type: 'create-issue',
        title: 'Issue without labels',
        body: 'Issue without labels'
      }]
    });
    process.env.GITHUB_AW_ISSUE_LABELS = '  , , ';
    
    const mockIssue = {
      number: 303,
      html_url: 'https://github.com/testowner/testrepo/issues/303'
    };
    
    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual([]);
    
    consoleSpy.mockRestore();
  });

  it('should include run information in issue body', async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [{
        type: 'create-issue',
        title: 'Test issue content',
        body: 'Test issue content'
      }]
    });
    
    const mockIssue = {
      number: 404,
      html_url: 'https://github.com/testowner/testrepo/issues/404'
    };
    
    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
    
    const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    
    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);
    
    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.body).toContain('Generated by Agentic Workflow Run');
    expect(callArgs.body).toContain('[12345]');
    expect(callArgs.body).toContain('https://github.com/testowner/testrepo/actions/runs/12345');
    
    consoleSpy.mockRestore();
  });
});