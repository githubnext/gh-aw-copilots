import { describe, it, expect, beforeEach, vi } from "vitest";
import fs from "fs";
import path from "path";

// Mock the global objects that GitHub Actions provides
const mockCore = {
  setOutput: vi.fn(),
  summary: {
    addRaw: vi.fn().mockReturnThis(),
    write: vi.fn(),
  },
};

const mockGithub = {
  rest: {
    issues: {
      create: vi.fn(),
      createComment: vi.fn(),
    },
  },
};

const mockContext = {
  runId: 12345,
  repo: {
    owner: "testowner",
    repo: "testrepo",
  },
  payload: {
    repository: {
      html_url: "https://github.com/testowner/testrepo",
    },
  },
};

// Set up global variables
global.core = mockCore;
global.github = mockGithub;
global.context = mockContext;

describe("create_issue.cjs", () => {
  let createIssueScript;

  beforeEach(() => {
    // Reset all mocks
    vi.clearAllMocks();

    // Reset environment variables
    delete process.env.GITHUB_AW_AGENT_OUTPUT;
    delete process.env.GITHUB_AW_ISSUE_LABELS;
    delete process.env.GITHUB_AW_ISSUE_TITLE_PREFIX;

    // Reset context
    delete global.context.payload.issue;

    // Read the script content
    const scriptPath = path.join(
      process.cwd(),
      "pkg/workflow/js/create_issue.cjs"
    );
    createIssueScript = fs.readFileSync(scriptPath, "utf8");
  });

  it("should skip when no agent output is provided", async () => {
    delete process.env.GITHUB_AW_AGENT_OUTPUT;

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(consoleSpy).toHaveBeenCalledWith(
      "No GITHUB_AW_AGENT_OUTPUT environment variable found"
    );
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();

    consoleSpy.mockRestore();
  });

  it("should skip when agent output is empty", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = "   ";

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(consoleSpy).toHaveBeenCalledWith("Agent output content is empty");
    expect(mockGithub.rest.issues.create).not.toHaveBeenCalled();

    consoleSpy.mockRestore();
  });

  it("should create issue with default title when only body content provided", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          body: "This is the issue body content",
        },
      ],
    });

    const mockIssue = {
      number: 456,
      html_url: "https://github.com/testowner/testrepo/issues/456",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    expect(mockGithub.rest.issues.create).toHaveBeenCalledWith({
      owner: "testowner",
      repo: "testrepo",
      title: "This is the issue body content",
      body: expect.stringContaining("Generated by Agentic Workflow Run"),
      labels: [],
    });

    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", 456);
    expect(mockCore.setOutput).toHaveBeenCalledWith(
      "issue_url",
      mockIssue.html_url
    );

    consoleSpy.mockRestore();
  });

  it("should extract title from markdown heading", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Bug Report",
          body: "This is a detailed bug description\n\nSteps to reproduce:\n1. Step one",
        },
      ],
    });

    const mockIssue = {
      number: 789,
      html_url: "https://github.com/testowner/testrepo/issues/789",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("Bug Report");
    expect(callArgs.body).toContain("This is a detailed bug description");
    expect(callArgs.body).toContain("Steps to reproduce:");

    consoleSpy.mockRestore();
  });

  it("should handle labels from environment variable", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Issue with labels",
          body: "Issue with labels",
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_LABELS = "bug, enhancement, high-priority";

    const mockIssue = {
      number: 101,
      html_url: "https://github.com/testowner/testrepo/issues/101",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual(["bug", "enhancement", "high-priority"]);

    consoleSpy.mockRestore();
  });

  it("should apply title prefix when provided", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Simple issue title",
          body: "Simple issue title",
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_TITLE_PREFIX = "[AUTO] ";

    const mockIssue = {
      number: 202,
      html_url: "https://github.com/testowner/testrepo/issues/202",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("[AUTO] Simple issue title");

    consoleSpy.mockRestore();
  });

  it("should not duplicate title prefix when already present", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "[AUTO] Issue title already prefixed",
          body: "Issue body content",
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_TITLE_PREFIX = "[AUTO] ";

    const mockIssue = {
      number: 203,
      html_url: "https://github.com/testowner/testrepo/issues/203",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.title).toBe("[AUTO] Issue title already prefixed"); // Should not be duplicated

    consoleSpy.mockRestore();
  });

  it("should handle parent issue context and create comment", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Child issue content",
          body: "Child issue content",
        },
      ],
    });
    global.context.payload.issue = { number: 555 };

    const mockIssue = {
      number: 666,
      html_url: "https://github.com/testowner/testrepo/issues/666",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });
    mockGithub.rest.issues.createComment.mockResolvedValue({});

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should create the child issue with reference to parent
    const createArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(createArgs.body).toContain("Related to #555");

    // Should create comment on parent issue
    expect(mockGithub.rest.issues.createComment).toHaveBeenCalledWith({
      owner: "testowner",
      repo: "testrepo",
      issue_number: 555,
      body: "Created related issue: #666",
    });

    consoleSpy.mockRestore();
  });

  it("should handle empty labels gracefully", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Issue without labels",
          body: "Issue without labels",
        },
      ],
    });
    process.env.GITHUB_AW_ISSUE_LABELS = "  , , ";

    const mockIssue = {
      number: 303,
      html_url: "https://github.com/testowner/testrepo/issues/303",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.labels).toEqual([]);

    consoleSpy.mockRestore();
  });

  it("should include run information in issue body", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Test issue content",
          body: "Test issue content",
        },
      ],
    });

    const mockIssue = {
      number: 404,
      html_url: "https://github.com/testowner/testrepo/issues/404",
    };

    mockGithub.rest.issues.create.mockResolvedValue({ data: mockIssue });

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    const callArgs = mockGithub.rest.issues.create.mock.calls[0][0];
    expect(callArgs.body).toContain("Generated by Agentic Workflow Run");
    expect(callArgs.body).toContain("[12345]");
    expect(callArgs.body).toContain(
      "https://github.com/testowner/testrepo/actions/runs/12345"
    );

    consoleSpy.mockRestore();
  });

  it("should handle disabled issues repository gracefully", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Test issue",
          body: "This should fail gracefully",
        },
      ],
    });

    // Mock GitHub API to throw the specific error for disabled issues
    const disabledError = new Error(
      "Issues has been disabled in this repository."
    );
    mockGithub.rest.issues.create.mockRejectedValue(disabledError);

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = vi
      .spyOn(console, "error")
      .mockImplementation(() => {});

    // Execute the script - should not throw error
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should log warning message instead of error
    expect(consoleSpy).toHaveBeenCalledWith(
      '⚠ Cannot create issue "Test issue": Issues are disabled for this repository'
    );
    expect(consoleSpy).toHaveBeenCalledWith(
      "Consider enabling issues in repository settings if you want to create issues automatically"
    );

    // Should not have called console.error for this specific error
    expect(consoleErrorSpy).not.toHaveBeenCalledWith(
      expect.stringContaining("✗ Failed to create issue")
    );

    // Should still log successful completion with 0 issues
    expect(consoleSpy).toHaveBeenCalledWith("Successfully created 0 issue(s)");

    // Should not set outputs since no issues were created
    expect(mockCore.setOutput).not.toHaveBeenCalled();

    consoleSpy.mockRestore();
    consoleErrorSpy.mockRestore();
  });

  it("should continue processing other issues when one fails due to disabled repository", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "First issue",
          body: "This will fail",
        },
        {
          type: "create-issue",
          title: "Second issue",
          body: "This should succeed",
        },
      ],
    });

    const disabledError = new Error(
      "Issues has been disabled in this repository."
    );
    const mockIssue = {
      number: 505,
      html_url: "https://github.com/testowner/testrepo/issues/505",
    };

    // First call fails with disabled error, second call succeeds
    mockGithub.rest.issues.create
      .mockRejectedValueOnce(disabledError)
      .mockResolvedValueOnce({ data: mockIssue });

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

    // Execute the script
    await eval(`(async () => { ${createIssueScript} })()`);

    // Should log warning for first issue
    expect(consoleSpy).toHaveBeenCalledWith(
      '⚠ Cannot create issue "First issue": Issues are disabled for this repository'
    );

    // Should log success for second issue
    expect(consoleSpy).toHaveBeenCalledWith(
      "Created issue #" + mockIssue.number + ": " + mockIssue.html_url
    );

    // Should report 1 issue created successfully
    expect(consoleSpy).toHaveBeenCalledWith("Successfully created 1 issue(s)");

    // Should set outputs for the successful issue
    expect(mockCore.setOutput).toHaveBeenCalledWith("issue_number", 505);
    expect(mockCore.setOutput).toHaveBeenCalledWith(
      "issue_url",
      mockIssue.html_url
    );

    consoleSpy.mockRestore();
  });

  it("should still throw error for other API errors", async () => {
    process.env.GITHUB_AW_AGENT_OUTPUT = JSON.stringify({
      items: [
        {
          type: "create-issue",
          title: "Test issue",
          body: "This should fail with different error",
        },
      ],
    });

    // Mock GitHub API to throw a different error
    const otherError = new Error("API rate limit exceeded");
    mockGithub.rest.issues.create.mockRejectedValue(otherError);

    const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});
    const consoleErrorSpy = vi
      .spyOn(console, "error")
      .mockImplementation(() => {});

    // Execute the script - should throw error for non-disabled-issues errors
    await expect(
      eval(`(async () => { ${createIssueScript} })()`)
    ).rejects.toThrow("API rate limit exceeded");

    // Should log error message for other errors
    expect(consoleErrorSpy).toHaveBeenCalledWith(
      '✗ Failed to create issue "Test issue":',
      "API rate limit exceeded"
    );

    consoleSpy.mockRestore();
    consoleErrorSpy.mockRestore();
  });
});
