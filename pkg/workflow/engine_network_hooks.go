package workflow

import (
	"encoding/json"
	"fmt"
	"strings"
)

// NetworkHookGenerator generates network permission hooks for engine configurations
type NetworkHookGenerator struct{}

// GenerateNetworkHookScript generates a Python hook script for network permissions
func (g *NetworkHookGenerator) GenerateNetworkHookScript(allowedDomains []string) string {
	// Convert domain list to JSON for embedding in Python
	// Ensure empty slice becomes [] not null in JSON
	var domainsJSON []byte
	if allowedDomains == nil {
		domainsJSON = []byte("[]")
	} else {
		domainsJSON, _ = json.Marshal(allowedDomains)
	}

	return fmt.Sprintf(`#!/usr/bin/env python3
"""
Network permissions validator for Claude Code engine.
Generated by gh-aw from engine network permissions configuration.
"""

import json
import sys
import urllib.parse
import re

# Domain allow-list (populated during generation)
ALLOWED_DOMAINS = %s

def extract_domain(url_or_query):
    """Extract domain from URL or search query."""
    if not url_or_query:
        return None
    
    if url_or_query.startswith(('http://', 'https://')):
        return urllib.parse.urlparse(url_or_query).netloc.lower()
    
    # Check for domain patterns in search queries
    match = re.search(r'site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', url_or_query)
    if match:
        return match.group(1).lower()
    
    return None

def is_domain_allowed(domain):
    """Check if domain is allowed."""
    if not domain:
        # If no domain detected, allow only if not under deny-all policy
        return bool(ALLOWED_DOMAINS)  # False if empty list (deny-all), True if has domains
    
    # Empty allowed domains means deny all
    if not ALLOWED_DOMAINS:
        return False
    
    for pattern in ALLOWED_DOMAINS:
        regex = pattern.replace('.', r'\.').replace('*', '.*')
        if re.match(f'^{regex}$', domain):
            return True
    return False

# Main logic
try:
    data = json.load(sys.stdin)
    tool_name = data.get('tool_name', '')
    tool_input = data.get('tool_input', {})
    
    if tool_name not in ['WebFetch', 'WebSearch']:
        sys.exit(0)  # Allow other tools
    
    target = tool_input.get('url') or tool_input.get('query', '')
    domain = extract_domain(target)
    
    # For WebSearch, apply domain restrictions consistently
    # If no domain detected in search query, check if restrictions are in place
    if tool_name == 'WebSearch' and not domain:
        # Since this hook is only generated when network permissions are configured,
        # empty ALLOWED_DOMAINS means deny-all policy
        if not ALLOWED_DOMAINS:  # Empty list means deny all
            print(f"Network access blocked: deny-all policy in effect", file=sys.stderr)
            print(f"No domains are allowed for WebSearch", file=sys.stderr)
            sys.exit(2)  # Block under deny-all policy
        else:
            print(f"Network access blocked for web-search: no specific domain detected", file=sys.stderr)
            print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
            sys.exit(2)  # Block general searches when domain allowlist is configured
    
    if not is_domain_allowed(domain):
        print(f"Network access blocked for domain: {domain}", file=sys.stderr)
        print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
        sys.exit(2)  # Block with feedback to Claude
    
    sys.exit(0)  # Allow
    
except Exception as e:
    print(f"Network validation error: {e}", file=sys.stderr)
    sys.exit(2)  # Block on errors
`, string(domainsJSON))
}

// GenerateNetworkHookWorkflowStep generates a GitHub Actions workflow step that creates the network permissions hook
func (g *NetworkHookGenerator) GenerateNetworkHookWorkflowStep(allowedDomains []string) GitHubActionStep {
	hookScript := g.GenerateNetworkHookScript(allowedDomains)

	// No escaping needed for heredoc with 'EOF' - it's literal
	runContent := fmt.Sprintf(`mkdir -p .claude/hooks
cat > .claude/hooks/network_permissions.py << 'EOF'
%s
EOF
chmod +x .claude/hooks/network_permissions.py`, hookScript)

	var lines []string
	lines = append(lines, "      - name: Generate Network Permissions Hook")
	lines = append(lines, "        run: |")

	// Split the run content into lines and properly indent
	runLines := strings.Split(runContent, "\n")
	for _, line := range runLines {
		lines = append(lines, fmt.Sprintf("          %s", line))
	}

	return GitHubActionStep(lines)
}

// getDefaultAllowedDomains returns the basic infrastructure domains for network: defaults mode
// Includes only essential infrastructure: certs, JSON schema, Ubuntu, common package mirrors, Microsoft sources
func getDefaultAllowedDomains() []string {
	return []string{
		// Certificate Authority and OCSP domains
		"crl3.digicert.com",
		"crl4.digicert.com",
		"ocsp.digicert.com",
		"ts-crl.ws.symantec.com",
		"ts-ocsp.ws.symantec.com",
		"crl.geotrust.com",
		"ocsp.geotrust.com",
		"crl.thawte.com",
		"ocsp.thawte.com",
		"crl.verisign.com",
		"ocsp.verisign.com",
		"crl.globalsign.com",
		"ocsp.globalsign.com",
		"crls.ssl.com",
		"ocsp.ssl.com",
		"crl.identrust.com",
		"ocsp.identrust.com",
		"crl.sectigo.com",
		"ocsp.sectigo.com",
		"crl.usertrust.com",
		"ocsp.usertrust.com",
		"s.symcb.com",
		"s.symcd.com",

		// JSON Schema
		"json-schema.org",
		"json.schemastore.org",

		// Ubuntu
		"archive.ubuntu.com",
		"security.ubuntu.com",
		"ppa.launchpad.net",
		"keyserver.ubuntu.com",
		"azure.archive.ubuntu.com",
		"api.snapcraft.io",

		// Common Package Mirrors
		"packagecloud.io",
		"packages.cloud.google.com",

		// Microsoft Sources
		"packages.microsoft.com",
	}
}

// getContainerDomains returns container registry domains
func getContainerDomains() []string {
	return []string{
		"ghcr.io",
		"registry.hub.docker.com",
		"*.docker.io",
		"*.docker.com",
		"production.cloudflare.docker.com",
		"dl.k8s.io",
		"pkgs.k8s.io",
		"quay.io",
		"mcr.microsoft.com",
		"gcr.io",
		"auth.docker.io",
	}
}

// getDotnetDomains returns .NET and NuGet domains
func getDotnetDomains() []string {
	return []string{
		"nuget.org",
		"dist.nuget.org",
		"api.nuget.org",
		"nuget.pkg.github.com",
		"dotnet.microsoft.com",
		"pkgs.dev.azure.com",
		"builds.dotnet.microsoft.com",
		"dotnetcli.blob.core.windows.net",
		"nugetregistryv2prod.blob.core.windows.net",
		"azuresearch-usnc.nuget.org",
		"azuresearch-ussc.nuget.org",
		"dc.services.visualstudio.com",
		"dot.net",
		"ci.dot.net",
		"www.microsoft.com",
		"oneocsp.microsoft.com",
	}
}

// getDartDomains returns Dart/Flutter domains
func getDartDomains() []string {
	return []string{
		"pub.dev",
		"pub.dartlang.org",
	}
}

// getGitHubDomains returns GitHub domains
func getGitHubDomains() []string {
	return []string{
		"*.githubusercontent.com",
		"raw.githubusercontent.com",
		"objects.githubusercontent.com",
		"lfs.github.com",
		"github-cloud.githubusercontent.com",
		"github-cloud.s3.amazonaws.com",
		"codeload.github.com",
	}
}

// getGoDomains returns Go ecosystem domains
func getGoDomains() []string {
	return []string{
		"go.dev",
		"golang.org",
		"proxy.golang.org",
		"sum.golang.org",
		"pkg.go.dev",
		"goproxy.io",
	}
}

// getTerraformDomains returns HashiCorp/Terraform domains
func getTerraformDomains() []string {
	return []string{
		"releases.hashicorp.com",
		"apt.releases.hashicorp.com",
		"yum.releases.hashicorp.com",
		"registry.terraform.io",
	}
}

// getHaskellDomains returns Haskell ecosystem domains
func getHaskellDomains() []string {
	return []string{
		"haskell.org",
		"*.hackage.haskell.org",
		"get-ghcup.haskell.org",
		"downloads.haskell.org",
	}
}

// getJavaDomains returns Java/Maven/Gradle domains
func getJavaDomains() []string {
	return []string{
		"www.java.com",
		"jdk.java.net",
		"api.adoptium.net",
		"adoptium.net",
		"repo.maven.apache.org",
		"maven.apache.org",
		"repo1.maven.org",
		"maven.pkg.github.com",
		"maven.oracle.com",
		"repo.spring.io",
		"gradle.org",
		"services.gradle.org",
		"plugins.gradle.org",
		"plugins-artifacts.gradle.org",
		"repo.grails.org",
		"download.eclipse.org",
		"download.oracle.com",
		"jcenter.bintray.com",
	}
}

// getLinuxDistrosDomains returns Linux package repository domains
func getLinuxDistrosDomains() []string {
	return []string{
		// Debian
		"deb.debian.org",
		"security.debian.org",
		"keyring.debian.org",
		"packages.debian.org",
		"debian.map.fastlydns.net",
		"apt.llvm.org",
		// Fedora
		"dl.fedoraproject.org",
		"mirrors.fedoraproject.org",
		"download.fedoraproject.org",
		// CentOS
		"mirror.centos.org",
		"vault.centos.org",
		// Alpine
		"dl-cdn.alpinelinux.org",
		"pkg.alpinelinux.org",
		// Arch
		"mirror.archlinux.org",
		"archlinux.org",
		// SUSE
		"download.opensuse.org",
		// Red Hat
		"cdn.redhat.com",
	}
}

// getNodeDomains returns Node.js/NPM/Yarn domains
func getNodeDomains() []string {
	return []string{
		"npmjs.org",
		"npmjs.com",
		"registry.npmjs.com",
		"registry.npmjs.org",
		"skimdb.npmjs.com",
		"npm.pkg.github.com",
		"api.npms.io",
		"nodejs.org",
		"yarnpkg.com",
		"registry.yarnpkg.com",
		"repo.yarnpkg.com",
		"deb.nodesource.com",
		"get.pnpm.io",
		"bun.sh",
		"deno.land",
		"registry.bower.io",
	}
}

// getPerlDomains returns Perl ecosystem domains
func getPerlDomains() []string {
	return []string{
		"cpan.org",
		"www.cpan.org",
		"metacpan.org",
		"cpan.metacpan.org",
	}
}

// getPhpDomains returns PHP ecosystem domains
func getPhpDomains() []string {
	return []string{
		"repo.packagist.org",
		"packagist.org",
		"getcomposer.org",
	}
}

// getPlaywrightDomains returns Playwright domains
func getPlaywrightDomains() []string {
	return []string{
		"playwright.download.prss.microsoft.com",
		"cdn.playwright.dev",
	}
}

// getPythonDomains returns Python ecosystem domains
func getPythonDomains() []string {
	return []string{
		"pypi.python.org",
		"pypi.org",
		"pip.pypa.io",
		"*.pythonhosted.org",
		"files.pythonhosted.org",
		"bootstrap.pypa.io",
		"conda.binstar.org",
		"conda.anaconda.org",
		"binstar.org",
		"anaconda.org",
		"repo.continuum.io",
		"repo.anaconda.com",
	}
}

// getRubyDomains returns Ruby ecosystem domains
func getRubyDomains() []string {
	return []string{
		"rubygems.org",
		"api.rubygems.org",
		"rubygems.pkg.github.com",
		"bundler.rubygems.org",
		"gems.rubyforge.org",
		"gems.rubyonrails.org",
		"index.rubygems.org",
		"cache.ruby-lang.org",
		"*.rvm.io",
	}
}

// getRustDomains returns Rust ecosystem domains
func getRustDomains() []string {
	return []string{
		"crates.io",
		"index.crates.io",
		"static.crates.io",
		"sh.rustup.rs",
		"static.rust-lang.org",
	}
}

// getSwiftDomains returns Swift ecosystem domains
func getSwiftDomains() []string {
	return []string{
		"download.swift.org",
		"swift.org",
		"cocoapods.org",
		"cdn.cocoapods.org",
	}
}

// ShouldEnforceNetworkPermissions checks if network permissions should be enforced
// Returns true if network permissions are configured and not in "defaults" mode
func ShouldEnforceNetworkPermissions(network *NetworkPermissions) bool {
	if network == nil {
		return false // No network config, defaults to full access
	}
	if network.Mode == "defaults" {
		return true // "defaults" mode uses restricted allow-list (enforcement needed)
	}
	return true // Object format means some restriction is configured
}

// GetAllowedDomains returns the allowed domains from network permissions
// Returns default allow-list if no network permissions configured or in "defaults" mode
// Returns empty slice if network permissions configured but no domains allowed (deny all)
// Returns domain list if network permissions configured with allowed domains
// Supports ecosystem identifiers:
//   - "defaults": basic infrastructure (certs, JSON schema, Ubuntu, common package mirrors, Microsoft sources)
//   - "containers": container registries (Docker, GitHub Container Registry, etc.)
//   - "dotnet": .NET and NuGet ecosystem
//   - "dart": Dart/Flutter ecosystem
//   - "github": GitHub domains
//   - "go": Go ecosystem
//   - "terraform": HashiCorp/Terraform
//   - "haskell": Haskell ecosystem
//   - "java": Java/Maven/Gradle
//   - "linux-distros": Linux distribution package repositories
//   - "node": Node.js/NPM/Yarn
//   - "perl": Perl/CPAN
//   - "php": PHP/Composer
//   - "playwright": Playwright testing framework
//   - "python": Python/PyPI/Conda
//   - "ruby": Ruby/RubyGems
//   - "rust": Rust/Cargo/Crates
//   - "swift": Swift/CocoaPods
func GetAllowedDomains(network *NetworkPermissions) []string {
	if network == nil {
		return getDefaultAllowedDomains() // Default allow-list for backwards compatibility
	}
	if network.Mode == "defaults" {
		return getDefaultAllowedDomains() // Default allow-list for defaults mode
	}

	// Handle empty allowed list (deny-all case)
	if len(network.Allowed) == 0 {
		return []string{} // Return empty slice, not nil
	}

	// Process the allowed list, expanding ecosystem identifiers if present
	var expandedDomains []string
	for _, domain := range network.Allowed {
		switch domain {
		case "defaults":
			// Expand "defaults" to basic infrastructure domains
			expandedDomains = append(expandedDomains, getDefaultAllowedDomains()...)
		case "containers":
			expandedDomains = append(expandedDomains, getContainerDomains()...)
		case "dotnet":
			expandedDomains = append(expandedDomains, getDotnetDomains()...)
		case "dart":
			expandedDomains = append(expandedDomains, getDartDomains()...)
		case "github":
			expandedDomains = append(expandedDomains, getGitHubDomains()...)
		case "go":
			expandedDomains = append(expandedDomains, getGoDomains()...)
		case "terraform":
			expandedDomains = append(expandedDomains, getTerraformDomains()...)
		case "haskell":
			expandedDomains = append(expandedDomains, getHaskellDomains()...)
		case "java":
			expandedDomains = append(expandedDomains, getJavaDomains()...)
		case "linux-distros":
			expandedDomains = append(expandedDomains, getLinuxDistrosDomains()...)
		case "node":
			expandedDomains = append(expandedDomains, getNodeDomains()...)
		case "perl":
			expandedDomains = append(expandedDomains, getPerlDomains()...)
		case "php":
			expandedDomains = append(expandedDomains, getPhpDomains()...)
		case "playwright":
			expandedDomains = append(expandedDomains, getPlaywrightDomains()...)
		case "python":
			expandedDomains = append(expandedDomains, getPythonDomains()...)
		case "ruby":
			expandedDomains = append(expandedDomains, getRubyDomains()...)
		case "rust":
			expandedDomains = append(expandedDomains, getRustDomains()...)
		case "swift":
			expandedDomains = append(expandedDomains, getSwiftDomains()...)
		default:
			// Add the domain as-is (regular domain name)
			expandedDomains = append(expandedDomains, domain)
		}
	}

	return expandedDomains
}

// GetDomainEcosystem returns the ecosystem identifier for a given domain, or empty string if not found
func GetDomainEcosystem(domain string) string {
	// Check if domain matches any ecosystem
	ecosystems := map[string]func() []string{
		"defaults":      getDefaultAllowedDomains,
		"containers":    getContainerDomains,
		"dotnet":        getDotnetDomains,
		"dart":          getDartDomains,
		"github":        getGitHubDomains,
		"go":            getGoDomains,
		"terraform":     getTerraformDomains,
		"haskell":       getHaskellDomains,
		"java":          getJavaDomains,
		"linux-distros": getLinuxDistrosDomains,
		"node":          getNodeDomains,
		"perl":          getPerlDomains,
		"php":           getPhpDomains,
		"playwright":    getPlaywrightDomains,
		"python":        getPythonDomains,
		"ruby":          getRubyDomains,
		"rust":          getRustDomains,
		"swift":         getSwiftDomains,
	}

	// Check each ecosystem for domain match
	for ecosystem, getDomainsFunc := range ecosystems {
		domains := getDomainsFunc()
		for _, ecosystemDomain := range domains {
			if matchesDomain(domain, ecosystemDomain) {
				return ecosystem
			}
		}
	}

	return "" // No ecosystem found
}

// matchesDomain checks if a domain matches a pattern (supports wildcards)
func matchesDomain(domain, pattern string) bool {
	// Exact match
	if domain == pattern {
		return true
	}

	// Wildcard match
	if strings.HasPrefix(pattern, "*.") {
		suffix := pattern[2:] // Remove "*."
		return strings.HasSuffix(domain, "."+suffix) || domain == suffix
	}

	return false
}

// HasNetworkPermissions is deprecated - use ShouldEnforceNetworkPermissions instead
// Kept for backwards compatibility but will be removed in future versions
func HasNetworkPermissions(engineConfig *EngineConfig) bool {
	// This function is now deprecated since network permissions are top-level
	// Return false for backwards compatibility
	return false
}
