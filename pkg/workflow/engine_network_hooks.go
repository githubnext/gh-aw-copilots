package workflow

import (
	"encoding/json"
	"fmt"
	"strings"
)

// NetworkHookGenerator generates network permission hooks for engine configurations
type NetworkHookGenerator struct{}

// GenerateNetworkHookScript generates a Python hook script for network permissions
func (g *NetworkHookGenerator) GenerateNetworkHookScript(allowedDomains []string) string {
	// Convert domain list to JSON for embedding in Python
	// Ensure empty slice becomes [] not null in JSON
	var domainsJSON []byte
	if allowedDomains == nil {
		domainsJSON = []byte("[]")
	} else {
		domainsJSON, _ = json.Marshal(allowedDomains)
	}

	return fmt.Sprintf(`#!/usr/bin/env python3
"""
Network permissions validator for Claude Code engine.
Generated by gh-aw from engine network permissions configuration.
"""

import json
import sys
import urllib.parse
import re

# Domain whitelist (populated during generation)
ALLOWED_DOMAINS = %s

def extract_domain(url_or_query):
    """Extract domain from URL or search query."""
    if not url_or_query:
        return None
    
    if url_or_query.startswith(('http://', 'https://')):
        return urllib.parse.urlparse(url_or_query).netloc.lower()
    
    # Check for domain patterns in search queries
    match = re.search(r'site:([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', url_or_query)
    if match:
        return match.group(1).lower()
    
    return None

def is_domain_allowed(domain):
    """Check if domain is allowed."""
    if not domain:
        # If no domain detected, allow only if not under deny-all policy
        return bool(ALLOWED_DOMAINS)  # False if empty list (deny-all), True if has domains
    
    # Empty allowed domains means deny all
    if not ALLOWED_DOMAINS:
        return False
    
    for pattern in ALLOWED_DOMAINS:
        regex = pattern.replace('.', r'\.').replace('*', '.*')
        if re.match(f'^{regex}$', domain):
            return True
    return False

# Main logic
try:
    data = json.load(sys.stdin)
    tool_name = data.get('tool_name', '')
    tool_input = data.get('tool_input', {})
    
    if tool_name not in ['WebFetch', 'WebSearch']:
        sys.exit(0)  # Allow other tools
    
    target = tool_input.get('url') or tool_input.get('query', '')
    domain = extract_domain(target)
    
    # For WebSearch, apply domain restrictions consistently
    # If no domain detected in search query, check if restrictions are in place
    if tool_name == 'WebSearch' and not domain:
        # Since this hook is only generated when network permissions are configured,
        # empty ALLOWED_DOMAINS means deny-all policy
        if not ALLOWED_DOMAINS:  # Empty list means deny all
            print(f"Network access blocked: deny-all policy in effect", file=sys.stderr)
            print(f"No domains are allowed for WebSearch", file=sys.stderr)
            sys.exit(2)  # Block under deny-all policy
        else:
            print(f"Network access blocked for WebSearch: no specific domain detected", file=sys.stderr)
            print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
            sys.exit(2)  # Block general searches when domain allowlist is configured
    
    if not is_domain_allowed(domain):
        print(f"Network access blocked for domain: {domain}", file=sys.stderr)
        print(f"Allowed domains: {', '.join(ALLOWED_DOMAINS)}", file=sys.stderr)
        sys.exit(2)  # Block with feedback to Claude
    
    sys.exit(0)  # Allow
    
except Exception as e:
    print(f"Network validation error: {e}", file=sys.stderr)
    sys.exit(2)  # Block on errors
`, string(domainsJSON))
}

// GenerateNetworkHookWorkflowStep generates a GitHub Actions workflow step that creates the network permissions hook
func (g *NetworkHookGenerator) GenerateNetworkHookWorkflowStep(allowedDomains []string) GitHubActionStep {
	hookScript := g.GenerateNetworkHookScript(allowedDomains)

	// No escaping needed for heredoc with 'EOF' - it's literal
	runContent := fmt.Sprintf(`mkdir -p .claude/hooks
cat > .claude/hooks/network_permissions.py << 'EOF'
%s
EOF
chmod +x .claude/hooks/network_permissions.py`, hookScript)

	var lines []string
	lines = append(lines, "      - name: Generate Network Permissions Hook")
	lines = append(lines, "        run: |")

	// Split the run content into lines and properly indent
	runLines := strings.Split(runContent, "\n")
	for _, line := range runLines {
		lines = append(lines, fmt.Sprintf("          %s", line))
	}

	return GitHubActionStep(lines)
}

// getDefaultAllowedDomains returns the default whitelist of domains for network: defaults mode
func getDefaultAllowedDomains() []string {
	return []string{
		// Certificate Authority and OCSP domains
		"crl3.digicert.com",
		"crl4.digicert.com",
		"ocsp.digicert.com",
		"ts-crl.ws.symantec.com",
		"ts-ocsp.ws.symantec.com",
		"crl.geotrust.com",
		"ocsp.geotrust.com",
		"crl.thawte.com",
		"ocsp.thawte.com",
		"crl.verisign.com",
		"ocsp.verisign.com",
		"crl.globalsign.com",
		"ocsp.globalsign.com",
		"crls.ssl.com",
		"ocsp.ssl.com",
		"crl.identrust.com",
		"ocsp.identrust.com",
		"crl.sectigo.com",
		"ocsp.sectigo.com",
		"crl.usertrust.com",
		"ocsp.usertrust.com",
		"s.symcb.com",
		"s.symcd.com",

		// Container Registries
		"ghcr.io",
		"registry.hub.docker.com",
		"*.docker.io",
		"*.docker.com",
		"production.cloudflare.docker.com",
		"dl.k8s.io",
		"pkgs.k8s.io",
		"quay.io",
		"mcr.microsoft.com",
		"gcr.io",
		"auth.docker.io",

		// .NET and NuGet
		"nuget.org",
		"dist.nuget.org",
		"api.nuget.org",
		"nuget.pkg.github.com",
		"dotnet.microsoft.com",
		"pkgs.dev.azure.com",
		"builds.dotnet.microsoft.com",
		"dotnetcli.blob.core.windows.net",
		"nugetregistryv2prod.blob.core.windows.net",
		"azuresearch-usnc.nuget.org",
		"azuresearch-ussc.nuget.org",
		"dc.services.visualstudio.com",
		"dot.net",
		"ci.dot.net",
		"www.microsoft.com",
		"oneocsp.microsoft.com",

		// Dart/Flutter
		"pub.dev",
		"pub.dartlang.org",

		// GitHub
		"*.githubusercontent.com",
		"raw.githubusercontent.com",
		"objects.githubusercontent.com",
		"lfs.github.com",
		"github-cloud.githubusercontent.com",
		"github-cloud.s3.amazonaws.com",
		"codeload.github.com",

		// Go
		"go.dev",
		"golang.org",
		"proxy.golang.org",
		"sum.golang.org",
		"pkg.go.dev",
		"goproxy.io",

		// HashiCorp
		"releases.hashicorp.com",
		"apt.releases.hashicorp.com",
		"yum.releases.hashicorp.com",
		"registry.terraform.io",

		// Haskell
		"haskell.org",
		"*.hackage.haskell.org",
		"get-ghcup.haskell.org",
		"downloads.haskell.org",

		// Java/Maven/Gradle
		"www.java.com",
		"jdk.java.net",
		"api.adoptium.net",
		"adoptium.net",
		"repo.maven.apache.org",
		"maven.apache.org",
		"repo1.maven.org",
		"maven.pkg.github.com",
		"maven.oracle.com",
		"repo.spring.io",
		"gradle.org",
		"services.gradle.org",
		"plugins.gradle.org",
		"plugins-artifacts.gradle.org",
		"repo.grails.org",
		"download.eclipse.org",
		"download.oracle.com",
		"jcenter.bintray.com",

		// JSON Schema
		"json-schema.org",
		"json.schemastore.org",

		// Linux Package Repositories
		// Ubuntu
		"archive.ubuntu.com",
		"security.ubuntu.com",
		"ppa.launchpad.net",
		"keyserver.ubuntu.com",
		"azure.archive.ubuntu.com",
		"api.snapcraft.io",
		// Debian
		"deb.debian.org",
		"security.debian.org",
		"keyring.debian.org",
		"packages.debian.org",
		"debian.map.fastlydns.net",
		"apt.llvm.org",
		// Fedora
		"dl.fedoraproject.org",
		"mirrors.fedoraproject.org",
		"download.fedoraproject.org",
		// CentOS
		"mirror.centos.org",
		"vault.centos.org",
		// Alpine
		"dl-cdn.alpinelinux.org",
		"pkg.alpinelinux.org",
		// Arch
		"mirror.archlinux.org",
		"archlinux.org",
		// SUSE
		"download.opensuse.org",
		// Red Hat
		"cdn.redhat.com",
		// Common Package Mirrors
		"packagecloud.io",
		"packages.cloud.google.com",
		// Microsoft Sources
		"packages.microsoft.com",

		// Node.js/NPM/Yarn
		"npmjs.org",
		"npmjs.com",
		"registry.npmjs.com",
		"registry.npmjs.org",
		"skimdb.npmjs.com",
		"npm.pkg.github.com",
		"api.npms.io",
		"nodejs.org",
		"yarnpkg.com",
		"registry.yarnpkg.com",
		"repo.yarnpkg.com",
		"deb.nodesource.com",
		"get.pnpm.io",
		"bun.sh",
		"deno.land",
		"registry.bower.io",

		// Perl
		"cpan.org",
		"www.cpan.org",
		"metacpan.org",
		"cpan.metacpan.org",

		// PHP
		"repo.packagist.org",
		"packagist.org",
		"getcomposer.org",

		// Playwright
		"playwright.download.prss.microsoft.com",
		"cdn.playwright.dev",

		// Python
		"pypi.python.org",
		"pypi.org",
		"pip.pypa.io",
		"*.pythonhosted.org",
		"files.pythonhosted.org",
		"bootstrap.pypa.io",
		"conda.binstar.org",
		"conda.anaconda.org",
		"binstar.org",
		"anaconda.org",
		"repo.continuum.io",
		"repo.anaconda.com",

		// Ruby
		"rubygems.org",
		"api.rubygems.org",
		"rubygems.pkg.github.com",
		"bundler.rubygems.org",
		"gems.rubyforge.org",
		"gems.rubyonrails.org",
		"index.rubygems.org",
		"cache.ruby-lang.org",
		"*.rvm.io",

		// Rust
		"crates.io",
		"index.crates.io",
		"static.crates.io",
		"sh.rustup.rs",
		"static.rust-lang.org",

		// Swift
		"download.swift.org",
		"swift.org",
		"cocoapods.org",
		"cdn.cocoapods.org",

		// TODO: paths
		//url: { scheme: ["https"], domain: storage.googleapis.com, path: "/pub-packages/" }
		//url: { scheme: ["https"], domain: storage.googleapis.com, path: "/proxy-golang-org-prod/" }
		//url: { scheme: ["https"], domain: uploads.github.com, path: "/copilot/chat/attachments/" }

	}
}

// ShouldEnforceNetworkPermissions checks if network permissions should be enforced
// Returns true if network permissions are configured and not in "defaults" mode
func ShouldEnforceNetworkPermissions(network *NetworkPermissions) bool {
	if network == nil {
		return false // No network config, defaults to full access
	}
	if network.Mode == "defaults" {
		return true // "defaults" mode uses restricted whitelist (enforcement needed)
	}
	return true // Object format means some restriction is configured
}

// GetAllowedDomains returns the allowed domains from network permissions
// Returns default whitelist if no network permissions configured or in "defaults" mode
// Returns empty slice if network permissions configured but no domains allowed (deny all)
// Returns domain list if network permissions configured with allowed domains
// If "defaults" appears in the allowed list, it's expanded to the default whitelist
func GetAllowedDomains(network *NetworkPermissions) []string {
	if network == nil {
		return getDefaultAllowedDomains() // Default whitelist for backwards compatibility
	}
	if network.Mode == "defaults" {
		return getDefaultAllowedDomains() // Default whitelist for defaults mode
	}

	// Handle empty allowed list (deny-all case)
	if len(network.Allowed) == 0 {
		return []string{} // Return empty slice, not nil
	}

	// Process the allowed list, expanding "defaults" if present
	var expandedDomains []string
	for _, domain := range network.Allowed {
		if domain == "defaults" {
			// Expand "defaults" to the full default whitelist
			expandedDomains = append(expandedDomains, getDefaultAllowedDomains()...)
		} else {
			// Add the domain as-is
			expandedDomains = append(expandedDomains, domain)
		}
	}

	return expandedDomains
}

// HasNetworkPermissions is deprecated - use ShouldEnforceNetworkPermissions instead
// Kept for backwards compatibility but will be removed in future versions
func HasNetworkPermissions(engineConfig *EngineConfig) bool {
	// This function is now deprecated since network permissions are top-level
	// Return false for backwards compatibility
	return false
}
